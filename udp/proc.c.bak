#include <linux/init.h>
#include <linux/module.h>
#include <linux/netfilter.h>
#include <linux/socket.h>
#include <linux/netfilter_ipv4.h>
#include <linux/skbuff.h>
#include <linux/netdevice.h>
#include <linux/netpoll.h>
#include <linux/inet.h>
#include <net/ip.h>
#include <net/udp.h>
#include <linux/if_ether.h>
#include <linux/time.h>
#include <linux/spinlock.h>
#include "proc.h"
#include "vip.h"
#include "setup.h"

struct udp_entry 
{
	__u32 ip;
	__u16 port;
	__u32 update;
	__s32 id;
	__s8  isext;
	__u8 mac[ETH_ALEN];
	struct udp_entry* pre;
	struct udp_entry* next;
};


struct stat_entry
{
	__s32  id;
	struct fwd_stat stat;
	__s8   flag;
	struct stat_entry*  next;
};

/* This needs to be a spinlock because cannot sleep */
static DEFINE_SPINLOCK(target_list_lock);

//static DEFINE_MUTEX(entry_mutex);
//用户链表
static struct udp_entry** udp_entrys;
static struct netpoll int_np_t;
static struct netpoll ext_np_t;

//把需要删除的放在链表中，统一删除
static struct udp_entry* del_udp_head;
static struct udp_entry* del_udp_tail;

//用于取得用户数据
#define MAX_LEN  2048
static const __s8 *data;

//广播地址
static __u8 broadcast_mac[ETH_ALEN] = { 0xff,0xff,0xff,0xff,0xff,0xff };
//用于统计的链表
static struct stat_entry **stat;

int isinLan(__u32 ip, __u32 selfip, __u32 network_mask)
{
	return ((ip & network_mask) == (selfip&network_mask));
}


static int is_extern_net(__u32 ip)
{
	return (ip == ext_self_ip);
}

static int is_inter_net(__u32 ip)
{
	return (ip == int_self_ip);
}

// debug use
static __s8 buffer[16];

__s8*  __inet_ntoa(__u32 in)
{
	__u8 *bytes = (__u8 *)&in;
	snprintf(buffer, sizeof(buffer), "%d.%d.%d.%d", bytes[0], bytes[1], bytes[2], bytes[3]);
	return buffer;
}

static struct stat_entry*  find_stat(__u16 pos, __s32 id)
{
	struct stat_entry *entry, *new;
	entry = stat[pos];
	//pr_notice("%s  %d\n", "start find", id, entry);
	while (entry != 0)
	{
		if (entry->id == id)		return entry;
		if (entry->next != 0)	entry = entry->next;
		else break;
	}
	return 0;	
}

static struct stat_entry* add_stat(struct stat_entry *newstat, __u16 pos, __s32 id)
{
	struct stat_entry *entry;
	entry = stat[pos];
	//pr_notice("%s  %d\n", "start find", id, entry);
	while (entry != 0)
	{
		if (entry->next != 0)	entry = entry->next;
		else break;
	}
	newstat->id = id;
	newstat->next = 0;
	if (entry == 0) stat[pos] = newstat;
	else	entry->next = newstat;
	newstat->flag = 0;
	return newstat;
}

void del_stream(__u16 port)
{	
	struct udp_entry *entry, *temp;
	struct stat_entry *s, *stemp;
	unsigned long flags;

	spin_lock_irqsave(&target_list_lock, flags);
	entry = udp_entrys[port];
	udp_entrys[port] = 0;
	s = stat[port];
	stat[port] = 0;
	spin_unlock_irqrestore(&target_list_lock, flags);

	while (entry != 0)
	{
		temp = entry;
		entry = entry->next;
		kfree(temp);
	}
	while (s != 0)
	{
		stemp = s;
		s = s->next;
		kfree(stemp);
	}	

}

int del_user(__u16 pos, __s32 id)
{
	unsigned long flags;
	struct udp_entry *new_entry, *entry;

	spin_lock_irqsave(&target_list_lock, flags);
	entry = udp_entrys[pos];
	while (entry)
	{
		if (entry->id == id)
		{
			if (entry->pre) entry->pre->next = entry->next;
			else {
				udp_entrys[pos] = entry->next;
			}
			if (entry->next) entry->next->pre = entry->pre;
			spin_unlock_irqrestore(&target_list_lock, flags);
			pr_notice("%s %d %d\n", "del one user", pos, id);
			kfree(entry);
			return 0;
		}
		if (entry->next != 0) entry = entry->next;
		else break;
	}	
	spin_unlock_irqrestore(&target_list_lock, flags);
	pr_notice("%s %d %d\n", "del one user,but find error", pos, id);
	return 0;
}

int add_user(__u16 pos, __s32 id, __u32 destip, __u16 destport)
{
	unsigned long flags;
	struct udp_entry *new_entry,*entry;

	new_entry = (struct udp_entry*)kzalloc(sizeof(struct udp_entry), GFP_ATOMIC);
	if (!new_entry) return -1;

	new_entry->ip = destip;
	new_entry->port = destport;
	new_entry->update = get_seconds();
	new_entry->id = id;
	if (isinLan(destip, ext_self_ip, ext_mask))		new_entry->isext = 1;
	else new_entry->isext = 0;	
	memcpy(new_entry->mac, broadcast_mac, ETH_ALEN);
	new_entry->next = 0;
	new_entry->pre = 0;

	spin_lock_irqsave(&target_list_lock, flags);
	entry = udp_entrys[pos];
	while (entry)
	{
		if (entry->next != 0) entry = entry->next;
		else break;		
	}
	if (entry == 0) udp_entrys[pos] = new_entry;
	else
	{
		entry->next = new_entry;
		new_entry->pre = entry;		
	}
	spin_unlock_irqrestore(&target_list_lock, flags);

	pr_notice("%s %d %d %d %d\n", "add one user", pos, id, destip, destport);
	return 0;
}

int send_tick(__u16 srcport, __u32 destip, __u16 destport, __s32 id)
{
	struct netpoll *np_t;
	__s32 node;
	__u8 *data;
	unsigned long flags;
	int i;
	__s8 *ptr;

	data = (__u8*)kzalloc(sizeof(__u8) * MAX_LEN, GFP_ATOMIC);
	if (!data) return -1;

	spin_lock_irqsave(&target_list_lock, flags);

	if (isinLan(destip, int_self_ip, int_mask))
	{
		np_t = &int_np_t;
		np_t->local_ip.ip = int_self_ip;
	}
	else
	{
		np_t = &ext_np_t;
		np_t->local_ip.ip = ext_self_ip;
	}	
	np_t->remote_ip.ip = destip;
	np_t->local_port = srcport;
	np_t->remote_port = destport;
	for (i = 0; i < ETH_ALEN; i++)
		np_t->remote_mac[i] = broadcast_mac[i];
	//memcpy(np_t->remote_mac, broadcast_mac, ETH_ALEN);

	node = id;
	ptr = (__s8*)&node;
	for (i = 0; i < sizeof(__s32); i++)
		*(data + sizeof(__s32) + i) = *(ptr + i);

	//memcpy(data + sizeof(__s32), &node, sizeof(__s32));
	// send 3 times
	netpoll_send_udp(np_t, data, 2*sizeof(__s32));
	netpoll_send_udp(np_t, data, 2 * sizeof(__s32));
	netpoll_send_udp(np_t, data, 2 * sizeof(__s32));

	spin_unlock_irqrestore(&target_list_lock, flags);

	kfree(data);
	return 0;
}

int proc_test(struct sk_buff *skb,struct udphdr *udph, struct iphdr *iph, struct ethhdr *eth)
{
	int i;
	struct netpoll *np_t;
	unsigned long flags;
	int  offset = sizeof(struct udphdr) + sizeof(struct iphdr);
	skb_copy_bits(skb, offset, data, skb->len - offset);

	spin_lock_irqsave(&target_list_lock, flags);
	if (is_inter_net(iph->saddr))   // intern network
	{
		np_t = &int_np_t;
	}
	else
	{
		np_t = &ext_np_t;
	}
	for (i = 0; i < ETH_ALEN; i++)
		np_t->remote_mac[i] = eth->h_source[i];

	//memcpy(np_t->remote_mac, eth->h_source, ETH_ALEN);
	np_t->local_ip.ip = iph->daddr; //  inet_addr
	np_t->remote_ip.ip = iph->saddr;
	np_t->local_port = htons(udph->dest);
	np_t->remote_port = htons(udph->source);
	netpoll_send_udp(np_t, data, ntohs(udph->len) - sizeof(struct udphdr));
	spin_unlock_irqrestore(&target_list_lock, flags);
	return  0;
}


int proc_heart(struct sk_buff *skb,struct udphdr *udph, struct iphdr *iph, struct ethhdr *eth,__u16 port)
{
	int i;
	struct udp_entry* new_entry;
	struct stat_entry *new_stat;

	unsigned long flags;
	__s32 id;
	__u16 num = port - MIN_PORT;
	int  offset = sizeof(struct udphdr) + sizeof(struct iphdr);
	int  pkglen = skb->len - offset;

	struct udp_entry* entry;
	int len;
	int start;
	struct stat_entry* sta;

	__u32 now = get_seconds();

	__s8 delflag = 0;

	//pr_notice("%s\n", "s0");

	skb_copy_bits(skb, offset, data, pkglen);

	//pr_notice("%s\n", "s1");

	
	id = *((__u32*)(data + sizeof(__u32)));
    
	//pr_notice("%s\n", "s2");

	new_entry = (struct udp_entry*)kzalloc(sizeof(struct udp_entry), GFP_ATOMIC);
	//new_entry = (struct udp_entry*)kmalloc(sizeof(struct udp_entry), 0);
	if (!new_entry) return -1;

	//pr_notice("%s\n", "s3");

	new_stat = (struct stat_entry*)kzalloc(sizeof(struct stat_entry), GFP_ATOMIC);
	//new_stat = (struct stat_entry*)kmalloc(sizeof(struct stat_entry), 0);
	if (!new_stat)
	{
		kfree(new_entry);
		return -1;
	}	
	//pr_notice("%s\n", "s4");

	//pr_notice("%s %d\n", "len is", pkglen);

	//spin_lock_irqsave(&target_list_lock, flags);

	if (id >= 0 && pkglen >= 7*sizeof(__u32))
	{
		len = pkglen - 2 * sizeof(__u32);
		start = 2 * sizeof(__u32);

		sta = find_stat(num, id);
		if (sta == 0) sta = add_stat(new_stat,num, id);
		else delflag = 1;
		//pr_notice("%s %d  %d\n", "numis ", num, id);
		 
		sta->stat.stream_num = 0;
		while ( len >= 5 * sizeof(__u32) )
		{
			sta->stat.id = id;
			sta->stat.stream[sta->stat.stream_num].id = *((__s32*)(data + start));
			start += sizeof(__s32);
			sta->stat.stream[sta->stat.stream_num].down_recv_lost = *((__s32*)(data + start));
			start += sizeof(__s32);
			sta->stat.stream[sta->stat.stream_num].down_fec_lost = *((__s32*)(data + start));
			start += sizeof(__s32);
			sta->stat.stream[sta->stat.stream_num].down_fill_lost = *((__s32*)(data + start));
			start += sizeof(__s32);
			sta->stat.stream[sta->stat.stream_num].down_save_data = *((__s32*)(data + start));
			start += sizeof(__s32);
			len -= 5 * sizeof(__s32);
			sta->stat.stream_num++;
		}
	}

   spin_lock_irqsave(&target_list_lock, flags);
	//printk("%s %s %d\n", "heart", __inet_ntoa(iph->saddr), htons(udph->source));
	//pr_notice("%s\n", "t1");
	entry = udp_entrys[num];
	while (entry != 0) 
	{
		//pr_notice("%s\n", "t2");

		//pr_notice("%s %d %d %s %d\n", "find it", entry->ip, iph->saddr, entry->port, htons(udph->source));
		//if (entry->ip == iph->saddr && entry->port == htons(udph->source))
		if(entry->id == id)
		{
			entry->update = now;
			entry->ip = iph->saddr;
			entry->port = htons(udph->source);
			spin_unlock_irqrestore(&target_list_lock, flags);
			if(delflag) kfree(new_stat);
			kfree(new_entry);
			return -1;
		}
		//pr_notice("%s\n", "t3");

		if (entry->next != 0) entry = entry->next;
		else break;
	}	

	//pr_notice("%s\n", "t4");

	new_entry->ip = iph->saddr;
	new_entry->port = htons(udph->source);
	new_entry->update = now;
	new_entry->id = id;

	//pr_notice("%s\n", "t5");

	new_entry->isext = is_extern_net(iph->daddr);

	//pr_notice("%s\n", "t6");

	for (i = 0; i < ETH_ALEN; i++)
		new_entry->mac[i] = eth->h_source[i];
	//memcpy(new_entry->mac, eth->h_source, ETH_ALEN);
	//pr_notice("%s\n", "t7");

	new_entry->next = 0;
	new_entry->pre = 0;
	if (entry == 0) udp_entrys[num] = new_entry;
	else 
	{
		entry->next = new_entry;
		new_entry->pre = entry;
	}
	//pr_notice("%s\n", "t8");

	spin_unlock_irqrestore(&target_list_lock, flags);
	if (delflag) kfree(new_stat);
	//kfree(new_stat);
	//kfree(new_entry);
	
	pr_notice("%s %d %d %s %d\n", "add user ", new_entry->id, new_entry->isext, __inet_ntoa(iph->saddr), htons(udph->source));
	//pr_notice("%s %x %x %x %x %x %x\n", "mac", new_entry->mac[0], new_entry->mac[1], new_entry->mac[2], new_entry->mac[3],
		//new_entry->mac[4], new_entry->mac[5]);
	return  0;
}


static void del_entry(__u16 num, struct udp_entry* p)
{
	if (p->pre) p->pre->next = p->next;
	else {
		udp_entrys[num] = p->next;
	}
	if (p->next) p->next->pre = p->pre;
	p->next = 0;
	del_udp_tail->next = p;
	del_udp_tail = p;	
}

struct fwd_stat find_userstat(__u16 pos, __s32 id)
{
	struct stat_entry*  entry;
	unsigned long flags;
	struct fwd_stat  ret;

	memset(&ret, 0, sizeof(struct fwd_stat));

	//pr_notice("%s %d %d\n", "find user ", pos, id);
	spin_lock_irqsave(&target_list_lock, flags);
	entry = find_stat(pos, id);
	if (entry == 0)
	{
		pr_notice("%s %d %d\n", "find user error", pos, id);
		spin_unlock_irqrestore(&target_list_lock, flags);
		return ret;

	}
	entry->flag = 0;
	spin_unlock_irqrestore(&target_list_lock, flags);

	/*pr_notice("%s %d %d %d  %d %d %d %d %d \n", "data ",
		pos,id,
		entry->id, 
		entry->stat.id,
		entry->stat.up_bytes,
		entry->stat.up_realpkgnum,
		entry->stat.up_start_seq, 
		entry->stat.up_end_seq);*/
	//mutex_unlock(&entry_mutex);
	return entry->stat;
} 


int proc_forward(struct sk_buff *skb,struct udphdr *udph, struct iphdr *iph,  __u16 port)
{
	int i;
	struct udp_entry *temp, *entry;
	struct stat_entry *new_stat;

	struct netpoll *np_t;
	unsigned long flags;
	__u16 len;
	__u16 pos;
	__s32 id;
	__u32 now;
	__u32 seq;
	int  offset = sizeof(struct udphdr) + sizeof(struct iphdr);
	__s8 delflag = 0;
	struct stat_entry* sta;
	
	skb_copy_bits(skb, offset, data, skb->len - offset);
	len = ntohs(udph->len);
	pos = port - MIN_PORT;
	id = *((__s32*)data);
	seq = *((__s32*)(data+sizeof(__s32)));

	//pr_notice("%s %d\n", "seq ",seq);

	new_stat = (struct stat_entry*)kzalloc(sizeof(struct stat_entry), GFP_ATOMIC);
	if (!new_stat)
	{
		return -1;
	}

	now = get_seconds();

	spin_lock_irqsave(&target_list_lock, flags);
	sta = find_stat(pos, id);	
	if (sta == 0) sta = add_stat(new_stat, pos, id);
	else delflag = 1;


	if (!sta->flag)
	{
		//pr_notice("%s  %d %d   %d\n", "start stat", id, pos,seq);
		sta->flag = 1;
		sta->stat.id = id;
		sta->stat.up_start_seq = seq;
		sta->stat.up_end_seq = seq;
		sta->stat.up_bytes = ntohs(udph->len) - sizeof(struct udphdr);
		sta->stat.up_realpkgnum = 1;
	}
	else
	{
		sta->stat.up_end_seq = seq;
		sta->stat.up_bytes += ntohs(udph->len) - sizeof(struct udphdr);
		sta->stat.up_realpkgnum++;
		//pr_notice("%s  %d %d   %d\n", "it stat", sta->stat.up_end_seq, sta->stat.up_bytes, sta->stat.up_realpkgnum);
	}
	

	entry = udp_entrys[pos];
	while (entry != 0) 
	{
		if (now - entry->update > 60 && entry->id > 0 ) 
		{
			temp = entry;
			entry = entry->next;
			pr_notice("%s %d\n", "del user",temp->id);
			del_entry(pos, temp);
			continue;
		}	
		if (entry->ip == iph->saddr && entry->port == htons(udph->source))
		{
			entry = entry->next;
			continue;
		}
		
		if (id != 0) {
			if (!(is_review(pos, id) && (entry->id == 0)) && (entry->id != UP_NODE) && !is_vip(pos, id)){
				entry = entry->next;
				continue;
			}
		}
		
		if (entry->isext)
		{
			np_t = &ext_np_t;
		}
		else
		{
			np_t = &int_np_t;
		}
		
		np_t->local_ip.ip = iph->daddr; // inet_addr
		np_t->remote_ip.ip = entry->ip;
		np_t->local_port = htons(udph->dest);
		np_t->remote_port = entry->port;

		for (i = 0; i < ETH_ALEN; i++)
			np_t->remote_mac[i] = entry->mac[i];

		//memcpy(np_t->remote_mac, entry->mac, ETH_ALEN);

		netpoll_send_udp(np_t, data, ntohs(udph->len) - sizeof(struct udphdr));
		entry = entry->next;
	}

	spin_unlock_irqrestore(&target_list_lock, flags);

	if (delflag) kfree(new_stat);
	// del udp_entry
	entry = del_udp_head->next;
	while (entry)
	{
		temp = entry;
		entry = entry->next;
		kfree(temp);
	}
	del_udp_head->next = 0;
	del_udp_tail = del_udp_head;

	return 0;
}


int init_proc(void)
{
	//udp_entrys = (struct udp_entry**)kmalloc(sizeof(struct udp_entry*) * STREAM_NUM, 0);           //最多1000路
	udp_entrys = (struct udp_entry**)kzalloc(sizeof(struct udp_entry*) * STREAM_NUM, GFP_ATOMIC);    //最多1000路
	if (!udp_entrys) return -1;

	stat = (struct stat_entry**)kzalloc(sizeof(struct stat_entry*) * STREAM_NUM, GFP_ATOMIC);    //最多1000路
	if (!stat)
	{
		kfree(udp_entrys);
		return -1;
	}
	
	del_udp_head = (struct udp_entry*)kzalloc(sizeof(struct udp_entry), GFP_ATOMIC);
	if (!del_udp_head)
	{
		kfree(udp_entrys);
		kfree(stat);
		return -1;
	}
	del_udp_head->next = 0;
	del_udp_tail = del_udp_head;

	data = (__u8*)kzalloc(sizeof(__u8) * MAX_LEN, GFP_ATOMIC);
	if (!data)
	{
		kfree(udp_entrys);
		kfree(stat);
		kfree(del_udp_head);
		return -1;
	}

	//memset(udp_entrys, 0, sizeof(struct udp_entry*) * STREAM_NUM);

	int_np_t.name = INTDEV_NAME;
	//pr_notice("%s\n", int_device);
	strlcpy(int_np_t.dev_name, int_device, IFNAMSIZ);
	netpoll_setup(&int_np_t);

	ext_np_t.name = EXTDEV_NAME;
	//pr_notice("%s\n", ext_device);
	strlcpy(ext_np_t.dev_name, ext_device, IFNAMSIZ);
	netpoll_setup(&ext_np_t);

	return 0;
}

void restart_proc(void)
{
	int i;
	struct udp_entry *entry,*temp;
	struct stat_entry *s, *stemp;
	unsigned long flags;

	for (i = 0; i < STREAM_NUM; i++)
	{		
		entry = udp_entrys[i];
		while (entry)
		{
			temp = entry;
			entry = entry->next;
			kfree(temp);
		}
		s = stat[i];
		while (s)
		{
			stemp = s;
			s = s->next;
			kfree(stemp);
		}
	}
}

void exit_proc(void)
{
	int i;
	struct udp_entry *entry, *temp;
	struct stat_entry *s, *stemp;

	for (i = 0; i < STREAM_NUM; i++)
	{
		entry = udp_entrys[i];
		while (entry)
		{
			temp = entry;
			entry = entry->next;
			kfree(temp);
		}
		s = stat[i];
		while (s)
		{
			stemp = s;
			s = s->next;
			kfree(stemp);
		}
	}
	kfree(udp_entrys);
	kfree(stat);
	kfree(data);
	kfree(del_udp_head);
}
